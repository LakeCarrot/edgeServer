/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package edgeServer;

import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import io.grpc.Server;
import io.grpc.ServerBuilder;
import io.grpc.stub.StreamObserver;
import java.io.IOException;
import java.net.InetAddress;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.logging.Logger;
import java.lang.Runtime;
import java.lang.Process;
import java.lang.Thread;
import java.io.InputStreamReader;
import java.io.BufferedReader;
import java.util.concurrent.TimeUnit;
import edgeOffloading.OffloadingGrpc;
import edgeOffloading.OffloadingOuterClass.OffloadingRequest;
import edgeOffloading.OffloadingOuterClass.OffloadingReply;

public class EdgeServer {
	private static final Logger logger = Logger.getLogger(EdgeServer.class.getName());
	private static final Map<String, Integer> IMAGEPOP = new HashMap<>();  // appId, app hit times
	private static final Map<String, Map<String, Double>> RATEMAP = new HashMap<>(); // appId, machineId, rate
	private Server server;

	private void start() throws IOException {
		/* The port on which the server should run */
		int port = 50051;
		server = ServerBuilder.forPort(port)
				.addService(new OffloadingImpl())
				.build()
				.start();
		logger.info("Server started, listening on " + port);
		Runtime.getRuntime().addShutdownHook(new Thread() {
			@Override
			public void run() {
				// Use stderr here since the logger may have been reset by its JVM shutdown hook.
				System.err.println("*** shutting down gRPC server since JVM is shutting down");
				EdgeServer.this.stop();
				System.err.println("*** server shut down");
			}
		});
	}

	private void stop() {
		if (server != null) {
			server.shutdown();
		}
	}

	/**
	 * Await termination on the main thread since the grpc library uses daemon threads.
	 */
	private void blockUntilShutdown() throws InterruptedException {
		if (server != null) {
			server.awaitTermination();
		}
	}

	/**
	 * Main launches the server from the command line.
	 */
	public static void main(String[] args) throws IOException, InterruptedException {
		final EdgeServer server = new EdgeServer();
		//Thread receiver = new Thread(new Receiver());
		//receiver.start();
		//Thread sender = new Thread(new Sender());
		//sender.start();
		server.start();
		server.blockUntilShutdown();
	}

	static class OffloadingImpl extends OffloadingGrpc.OffloadingImplBase {

		@Override
		public void startService(OffloadingRequest req, StreamObserver<OffloadingReply> responseObserver) {
			// first, make the scheduling decision
			String appId = req.getMessage();
			System.out.println("appId: " + appId);
			try {
				String ip = InetAddress.getLocalHost().toString();
				System.out.println("ip: " + ip);
			} catch (Exception e) {
				System.out.println(e);
			}
			Map<String, Double> scheduleMeta = RATEMAP.get(appId);
			if (scheduleMeta == null) {
				// this appId is new to the neighborhood, so run it locally

			} else {

			}



			String reqMessage = req.getMessage();
			if (IMAGEPOP.containsKey(reqMessage)) {
				// edge server already has the requested docker image
				IMAGEPOP.put(reqMessage, IMAGEPOP.get(reqMessage) + 1);
			} else {
				// edge server needs to download the docker image on demand
				IMAGEPOP.put(reqMessage, 1);
				Runtime rt = Runtime.getRuntime();
				try {
					String command = "docker pull " + reqMessage;
					System.out.println("pull the container " + reqMessage);
					Process pr = rt.exec(command);
					BufferedReader in = new BufferedReader(new InputStreamReader(pr.getInputStream()));
					String inputLine;
					while((inputLine = in.readLine()) != null) {
						System.out.println(inputLine);
					}
					in.close();
				} catch (IOException e) {
					Thread.currentThread().interrupt();
				}
			}
			System.out.println("[DEBUG] request: " + reqMessage +", times: " + IMAGEPOP.get(reqMessage));

			EdgeServer s = new EdgeServer();
			OffloadingReply reply = OffloadingReply.newBuilder()
					.setMessage("I am your father! \\\\(* W *)//")
					.build();
			Thread t = s.new offloadThread(reqMessage);
			t.start();
			System.out.println("Check " + reqMessage + " container");
			while(!containerReady(reqMessage.split("/")[1])) {
				try {
					TimeUnit.MILLISECONDS.sleep(100);
				} catch (InterruptedException e) {
					Thread.currentThread().interrupt();
				}
			}
			/*
			try {
				TimeUnit.MILLISECONDS.sleep(10000);
			} catch (InterruptedException e) {
				Thread.currentThread().interrupt();
			}
			*/
			responseObserver.onNext(reply);
			responseObserver.onCompleted();
		}

		private boolean containerReady(String name) {
			Runtime rt = Runtime.getRuntime();
			try {
				// Execute the command
				String command = "docker container inspect -f {{.State.Running}} " + name;
				Process pr = rt.exec(command);

				// Get the input steam and read from it
				BufferedReader in = new BufferedReader(new InputStreamReader(pr.getInputStream()));
				String debug;
				while((debug = in.readLine()) != null) {
					if(debug.equals("true"))
						System.out.println(name + " is ready to serve!");
					return true;
				}
				return false;
			} catch (IOException e) {
				return false;
			}
		}
	}

	public class offloadThread extends Thread {
		String dockerName;
		public offloadThread(String dockerName) {
			this.dockerName = dockerName;
		}

		public void run() {
			Runtime rt = Runtime.getRuntime();
			try {
				String command = "docker run -p 50052:50052 --name " + dockerName.split("/")[1] + "  " + dockerName;
				System.out.println("[DEBUG] command: " + command);
				Process pr = rt.exec(command);
				BufferedReader in = new BufferedReader(new InputStreamReader(pr.getInputStream()));
				String inputLine;
				while((inputLine = in.readLine()) != null) {
					System.out.println(inputLine);
				}
				in.close();
				System.out.println("Input end");
				System.out.println("start the container");
			} catch (IOException e) {
				Thread.currentThread().interrupt();
			}
		}
	}
}
